"""Self-consistent Kohn-Sham LDA/LSDA solver for simple spherical atoms."""

from __future__ import annotations

from dataclasses import dataclass

import numpy as np

from .functionals import lda_xc_unpolarized
from .grid import make_radial_grid, normalize_density_to_electron_count, spherical_integral
from .lsda import lsda_xc, resolve_spin_configuration, split_density_from_polarization
from .models import AtomicSystem, OrbitalResult, SCFParameters, SCFResult
from .occupations import OccupiedState, RadialState, fill_occupations
from .potentials import external_potential_coulomb, hartree_potential_spherical
from .radial_solver import solve_radial_kohn_sham


@dataclass(slots=True)
class _SCFStepLDA:
    """Data generated by one fixed-potential KS solve in LDA mode."""

    effective_potential: np.ndarray
    proposed_density: np.ndarray
    occupied_states: list[OccupiedState]
    eigenvalue_sum: float
    hartree_energy: float
    xc_energy: float
    xc_potential_energy: float
    total_energy: float


@dataclass(slots=True)
class _SCFStepLSDA:
    """Data generated by one fixed-potential KS solve in LSDA mode."""

    effective_potential_up: np.ndarray
    effective_potential_down: np.ndarray
    proposed_density_up: np.ndarray
    proposed_density_down: np.ndarray
    occupied_states_up: list[OccupiedState]
    occupied_states_down: list[OccupiedState]
    eigenvalue_sum: float
    hartree_energy: float
    xc_energy: float
    xc_potential_energy: float
    total_energy: float


def run_scf(system: AtomicSystem, params: SCFParameters | None = None) -> SCFResult:
    """Run a Kohn-Sham SCF calculation for a simple spherical atom."""

    settings = params or SCFParameters()
    xc_model = settings.xc_model.strip().upper()

    if xc_model == "LDA":
        return _run_scf_lda(system, settings)
    if xc_model == "LSDA":
        return _run_scf_lsda(system, settings)

    raise ValueError("xc_model must be either 'LDA' or 'LSDA'")


def _run_scf_lda(system: AtomicSystem, settings: SCFParameters) -> SCFResult:
    """Run standard spin-unpolarized LDA SCF."""

    r = make_radial_grid(settings.r_max, settings.num_points)
    density = _initial_density_guess(system, r)

    converged = False
    residual = np.inf
    iterations = 0

    for iterations in range(1, settings.max_iterations + 1):
        step = _single_ks_step_lda(system, settings, r, density)

        mixed = (1.0 - settings.density_mixing) * density + settings.density_mixing * step.proposed_density
        mixed = np.maximum(mixed, 0.0)
        mixed = normalize_density_to_electron_count(mixed, r, system.electrons)

        residual = float(np.max(np.abs(mixed - density)))
        density = mixed

        if residual < settings.density_tolerance:
            converged = True
            break

    report_step = _single_ks_step_lda(system, settings, r, density)
    output_density = np.maximum(report_step.proposed_density, 0.0)
    output_density = normalize_density_to_electron_count(output_density, r, system.electrons)

    # In unpolarized mode, spin densities are represented as equal halves.
    density_up = 0.5 * output_density
    density_down = 0.5 * output_density

    return SCFResult(
        converged=converged,
        iterations=iterations,
        total_energy=report_step.total_energy,
        eigenvalue_sum=report_step.eigenvalue_sum,
        hartree_energy=report_step.hartree_energy,
        xc_energy=report_step.xc_energy,
        xc_potential_energy=report_step.xc_potential_energy,
        density_residual=residual,
        system=system,
        parameters=settings,
        orbitals=[
            OrbitalResult(
                n_index=occupied.state.n_index,
                l=occupied.state.l,
                occupancy=float(occupied.occupancy),
                energy=float(occupied.state.energy),
                spin="paired",
            )
            for occupied in report_step.occupied_states
        ],
        radial_grid=r.tolist(),
        density=output_density.tolist(),
        density_up=density_up.tolist(),
        density_down=density_down.tolist(),
        effective_potential=report_step.effective_potential.tolist(),
        effective_potential_up=report_step.effective_potential.tolist(),
        effective_potential_down=report_step.effective_potential.tolist(),
        xc_model="LDA",
        spin_up_electrons=float(system.electrons) / 2.0,
        spin_down_electrons=float(system.electrons) / 2.0,
        spin_polarization=0.0,
        notes=_build_notes(system, settings, xc_model="LDA"),
    )


def _run_scf_lsda(system: AtomicSystem, settings: SCFParameters) -> SCFResult:
    """Run spin-polarized LSDA SCF."""

    n_up_electrons, n_down_electrons, target_zeta = resolve_spin_configuration(
        electrons=system.electrons,
        spin_polarization=settings.spin_polarization,
    )

    r = make_radial_grid(settings.r_max, settings.num_points)
    density_guess = _initial_density_guess(system, r)
    density_up, density_down = split_density_from_polarization(density_guess, target_zeta)

    density_up = _normalize_component_density(density_up, r, n_up_electrons)
    density_down = _normalize_component_density(density_down, r, n_down_electrons)

    converged = False
    residual = np.inf
    iterations = 0

    for iterations in range(1, settings.max_iterations + 1):
        step = _single_ks_step_lsda(
            system=system,
            params=settings,
            r=r,
            input_density_up=density_up,
            input_density_down=density_down,
            electrons_up=n_up_electrons,
            electrons_down=n_down_electrons,
        )

        mixed_up = (1.0 - settings.density_mixing) * density_up + settings.density_mixing * step.proposed_density_up
        mixed_down = (1.0 - settings.density_mixing) * density_down + settings.density_mixing * step.proposed_density_down

        mixed_up = _normalize_component_density(np.maximum(mixed_up, 0.0), r, n_up_electrons)
        mixed_down = _normalize_component_density(np.maximum(mixed_down, 0.0), r, n_down_electrons)

        residual_up = float(np.max(np.abs(mixed_up - density_up)))
        residual_down = float(np.max(np.abs(mixed_down - density_down)))
        residual = max(residual_up, residual_down)

        density_up = mixed_up
        density_down = mixed_down

        if residual < settings.density_tolerance:
            converged = True
            break

    report_step = _single_ks_step_lsda(
        system=system,
        params=settings,
        r=r,
        input_density_up=density_up,
        input_density_down=density_down,
        electrons_up=n_up_electrons,
        electrons_down=n_down_electrons,
    )

    output_up = _normalize_component_density(
        np.maximum(report_step.proposed_density_up, 0.0),
        r,
        n_up_electrons,
    )
    output_down = _normalize_component_density(
        np.maximum(report_step.proposed_density_down, 0.0),
        r,
        n_down_electrons,
    )
    output_total = output_up + output_down

    effective_potential_avg = 0.5 * (report_step.effective_potential_up + report_step.effective_potential_down)

    orbitals = [
        OrbitalResult(
            n_index=occupied.state.n_index,
            l=occupied.state.l,
            occupancy=float(occupied.occupancy),
            energy=float(occupied.state.energy),
            spin="up",
        )
        for occupied in report_step.occupied_states_up
    ]
    orbitals.extend(
        OrbitalResult(
            n_index=occupied.state.n_index,
            l=occupied.state.l,
            occupancy=float(occupied.occupancy),
            energy=float(occupied.state.energy),
            spin="down",
        )
        for occupied in report_step.occupied_states_down
    )

    achieved_zeta = 0.0
    if system.electrons > 0:
        achieved_zeta = (n_up_electrons - n_down_electrons) / float(system.electrons)

    return SCFResult(
        converged=converged,
        iterations=iterations,
        total_energy=report_step.total_energy,
        eigenvalue_sum=report_step.eigenvalue_sum,
        hartree_energy=report_step.hartree_energy,
        xc_energy=report_step.xc_energy,
        xc_potential_energy=report_step.xc_potential_energy,
        density_residual=residual,
        system=system,
        parameters=settings,
        orbitals=orbitals,
        radial_grid=r.tolist(),
        density=output_total.tolist(),
        density_up=output_up.tolist(),
        density_down=output_down.tolist(),
        effective_potential=effective_potential_avg.tolist(),
        effective_potential_up=report_step.effective_potential_up.tolist(),
        effective_potential_down=report_step.effective_potential_down.tolist(),
        xc_model="LSDA",
        spin_up_electrons=float(n_up_electrons),
        spin_down_electrons=float(n_down_electrons),
        spin_polarization=float(achieved_zeta),
        notes=_build_notes(
            system,
            settings,
            xc_model="LSDA",
            spin_up=n_up_electrons,
            spin_down=n_down_electrons,
        ),
    )


def _single_ks_step_lda(
    system: AtomicSystem,
    params: SCFParameters,
    r: np.ndarray,
    input_density: np.ndarray,
) -> _SCFStepLDA:
    """Solve one fixed-potential KS problem from an input density (LDA)."""

    v_ext = external_potential_coulomb(system.atomic_number, r)

    if params.use_hartree:
        v_h = hartree_potential_spherical(input_density, r)
    else:
        v_h = np.zeros_like(r)

    eps_xc, v_xc = lda_xc_unpolarized(
        input_density,
        use_exchange=params.use_exchange,
        use_correlation=params.use_correlation,
    )

    effective_potential = v_ext + v_h + v_xc

    radial_states: list[RadialState] = []
    for l in range(params.l_max + 1):
        energies, orbitals = solve_radial_kohn_sham(
            r=r,
            effective_potential=effective_potential,
            l=l,
            num_states=params.states_per_l,
        )
        for n_index, (energy, orbital) in enumerate(zip(energies, orbitals), start=1):
            radial_states.append(
                RadialState(
                    n_index=n_index,
                    l=l,
                    energy=float(energy),
                    orbital=orbital,
                )
            )

    occupied = fill_occupations(radial_states, electrons=system.electrons, spin_channels=2)
    proposed_density = _density_from_states(occupied, r)
    proposed_density = np.maximum(proposed_density, 0.0)
    proposed_density = normalize_density_to_electron_count(proposed_density, r, system.electrons)

    eigenvalue_sum = sum(state.occupancy * state.state.energy for state in occupied)
    hartree_energy = 0.5 * spherical_integral(input_density * v_h, r)
    xc_energy = spherical_integral(input_density * eps_xc, r)
    xc_potential_energy = spherical_integral(input_density * v_xc, r)
    total_energy = eigenvalue_sum - hartree_energy + xc_energy - xc_potential_energy

    return _SCFStepLDA(
        effective_potential=effective_potential,
        proposed_density=proposed_density,
        occupied_states=occupied,
        eigenvalue_sum=float(eigenvalue_sum),
        hartree_energy=float(hartree_energy),
        xc_energy=float(xc_energy),
        xc_potential_energy=float(xc_potential_energy),
        total_energy=float(total_energy),
    )


def _single_ks_step_lsda(
    system: AtomicSystem,
    params: SCFParameters,
    r: np.ndarray,
    input_density_up: np.ndarray,
    input_density_down: np.ndarray,
    electrons_up: float,
    electrons_down: float,
) -> _SCFStepLSDA:
    """Solve one fixed-potential KS problem from spin densities (LSDA)."""

    total_density = input_density_up + input_density_down

    v_ext = external_potential_coulomb(system.atomic_number, r)
    if params.use_hartree:
        v_h = hartree_potential_spherical(total_density, r)
    else:
        v_h = np.zeros_like(r)

    eps_xc, v_xc_up, v_xc_down, _zeta = lsda_xc(
        input_density_up,
        input_density_down,
        use_exchange=params.use_exchange,
        use_correlation=params.use_correlation,
    )

    effective_up = v_ext + v_h + v_xc_up
    effective_down = v_ext + v_h + v_xc_down

    states_up: list[RadialState] = []
    states_down: list[RadialState] = []

    for l in range(params.l_max + 1):
        energies_up, orbitals_up = solve_radial_kohn_sham(
            r=r,
            effective_potential=effective_up,
            l=l,
            num_states=params.states_per_l,
        )
        for n_index, (energy, orbital) in enumerate(zip(energies_up, orbitals_up), start=1):
            states_up.append(RadialState(n_index=n_index, l=l, energy=float(energy), orbital=orbital))

        energies_down, orbitals_down = solve_radial_kohn_sham(
            r=r,
            effective_potential=effective_down,
            l=l,
            num_states=params.states_per_l,
        )
        for n_index, (energy, orbital) in enumerate(zip(energies_down, orbitals_down), start=1):
            states_down.append(RadialState(n_index=n_index, l=l, energy=float(energy), orbital=orbital))

    occupied_up = fill_occupations(states_up, electrons=electrons_up, spin_channels=1)
    occupied_down = fill_occupations(states_down, electrons=electrons_down, spin_channels=1)

    proposed_up = _density_from_states(occupied_up, r)
    proposed_down = _density_from_states(occupied_down, r)

    proposed_up = _normalize_component_density(np.maximum(proposed_up, 0.0), r, electrons_up)
    proposed_down = _normalize_component_density(np.maximum(proposed_down, 0.0), r, electrons_down)

    eigenvalue_sum = sum(state.occupancy * state.state.energy for state in occupied_up)
    eigenvalue_sum += sum(state.occupancy * state.state.energy for state in occupied_down)

    hartree_energy = 0.5 * spherical_integral(total_density * v_h, r)
    xc_energy = spherical_integral(total_density * eps_xc, r)
    xc_potential_energy = spherical_integral(
        input_density_up * v_xc_up + input_density_down * v_xc_down,
        r,
    )
    total_energy = eigenvalue_sum - hartree_energy + xc_energy - xc_potential_energy

    return _SCFStepLSDA(
        effective_potential_up=effective_up,
        effective_potential_down=effective_down,
        proposed_density_up=proposed_up,
        proposed_density_down=proposed_down,
        occupied_states_up=occupied_up,
        occupied_states_down=occupied_down,
        eigenvalue_sum=float(eigenvalue_sum),
        hartree_energy=float(hartree_energy),
        xc_energy=float(xc_energy),
        xc_potential_energy=float(xc_potential_energy),
        total_energy=float(total_energy),
    )


def _density_from_states(occupied_states: list[OccupiedState], r: np.ndarray) -> np.ndarray:
    """Build n(r) from occupied radial states."""

    density = np.zeros_like(r)
    factor = 1.0 / (4.0 * np.pi * r * r)

    for occupied in occupied_states:
        density += occupied.occupancy * occupied.state.orbital * occupied.state.orbital * factor

    return density


def _normalize_component_density(density: np.ndarray, r: np.ndarray, electrons: float) -> np.ndarray:
    """Normalize one spin-density component, or return zeros for empty channel."""

    if electrons <= 1.0e-12:
        return np.zeros_like(density)
    return normalize_density_to_electron_count(density, r, electrons)


def _initial_density_guess(system: AtomicSystem, r: np.ndarray) -> np.ndarray:
    """Hydrogenic starting guess with simple screening."""

    effective_z = max(0.5, float(system.atomic_number) - 0.35 * max(system.electrons - 1, 0))
    guess = (effective_z**3 / np.pi) * np.exp(-2.0 * effective_z * r)
    guess = guess * max(system.electrons, 1)
    guess = np.maximum(guess, 1.0e-12)

    return normalize_density_to_electron_count(guess, r, system.electrons)


def _build_notes(
    system: AtomicSystem,
    params: SCFParameters,
    xc_model: str,
    spin_up: float | None = None,
    spin_down: float | None = None,
) -> list[str]:
    """Short notes to clarify simplifying assumptions."""

    notes = [
        "Educational finite-difference radial implementation.",
        "Accuracy depends on radial grid resolution and SCF mixing settings.",
    ]

    if xc_model == "LSDA":
        notes.append("Spin-polarized LSDA enabled (Dirac exchange + Perdew-Zunger correlation).")
        if spin_up is not None and spin_down is not None:
            notes.append(f"Spin channel populations: N_up={spin_up:.3f}, N_down={spin_down:.3f}.")
            notes.append(
                "LSDA often lowers total energy for open-shell atoms by allowing spin asymmetry."
            )
    else:
        notes.append("Spin-unpolarized LDA (Dirac exchange + Perdew-Zunger correlation).")

    if system.electrons > 10:
        notes.append(
            "Warning: high electron counts may need larger l_max/states_per_l for stable occupation filling."
        )

    if not params.use_hartree:
        notes.append("Hartree term disabled (single-particle benchmark mode).")
    if not params.use_exchange and not params.use_correlation:
        notes.append("Exchange-correlation disabled.")

    return notes
