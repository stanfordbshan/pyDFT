"""Self-consistent Kohn-Sham LDA solver for simple spherical atoms."""

from __future__ import annotations

from dataclasses import dataclass

import numpy as np

from .functionals import lda_xc_unpolarized
from .grid import make_radial_grid, normalize_density_to_electron_count, spherical_integral
from .models import AtomicSystem, OrbitalResult, SCFParameters, SCFResult
from .occupations import OccupiedState, RadialState, fill_occupations
from .potentials import external_potential_coulomb, hartree_potential_spherical
from .radial_solver import solve_radial_kohn_sham


@dataclass(slots=True)
class _SCFStep:
    """Data generated by one fixed-potential Kohn-Sham solve."""

    effective_potential: np.ndarray
    proposed_density: np.ndarray
    occupied_states: list[OccupiedState]
    eigenvalue_sum: float
    hartree_energy: float
    xc_energy: float
    xc_potential_energy: float
    total_energy: float


def run_scf(system: AtomicSystem, params: SCFParameters | None = None) -> SCFResult:
    """Run an LDA Kohn-Sham SCF calculation for a simple spherical atom.

    This implementation prioritizes readability and educational value.
    """

    settings = params or SCFParameters()
    r = make_radial_grid(settings.r_max, settings.num_points)

    density = _initial_density_guess(system, r)

    converged = False
    residual = np.inf
    iterations = 0

    for iterations in range(1, settings.max_iterations + 1):
        step = _single_ks_step(system, settings, r, density)

        mixed = (1.0 - settings.density_mixing) * density + settings.density_mixing * step.proposed_density
        mixed = np.maximum(mixed, 0.0)
        mixed = normalize_density_to_electron_count(mixed, r, system.electrons)

        residual = float(np.max(np.abs(mixed - density)))
        density = mixed

        if residual < settings.density_tolerance:
            converged = True
            break

    # Final reporting step from the converged (or last) density.
    report_step = _single_ks_step(system, settings, r, density)
    output_density = np.maximum(report_step.proposed_density, 0.0)
    output_density = normalize_density_to_electron_count(output_density, r, system.electrons)

    return SCFResult(
        converged=converged,
        iterations=iterations,
        total_energy=report_step.total_energy,
        eigenvalue_sum=report_step.eigenvalue_sum,
        hartree_energy=report_step.hartree_energy,
        xc_energy=report_step.xc_energy,
        xc_potential_energy=report_step.xc_potential_energy,
        density_residual=residual,
        system=system,
        parameters=settings,
        orbitals=[
            OrbitalResult(
                n_index=occupied.state.n_index,
                l=occupied.state.l,
                occupancy=float(occupied.occupancy),
                energy=float(occupied.state.energy),
            )
            for occupied in report_step.occupied_states
        ],
        radial_grid=r.tolist(),
        density=output_density.tolist(),
        effective_potential=report_step.effective_potential.tolist(),
        notes=_build_notes(system, settings),
    )


def _single_ks_step(
    system: AtomicSystem,
    params: SCFParameters,
    r: np.ndarray,
    input_density: np.ndarray,
) -> _SCFStep:
    """Solve one fixed-potential KS problem from an input density."""

    v_ext = external_potential_coulomb(system.atomic_number, r)

    if params.use_hartree:
        v_h = hartree_potential_spherical(input_density, r)
    else:
        v_h = np.zeros_like(r)

    eps_xc, v_xc = lda_xc_unpolarized(
        input_density,
        use_exchange=params.use_exchange,
        use_correlation=params.use_correlation,
    )

    effective_potential = v_ext + v_h + v_xc

    radial_states: list[RadialState] = []
    for l in range(params.l_max + 1):
        energies, orbitals = solve_radial_kohn_sham(
            r=r,
            effective_potential=effective_potential,
            l=l,
            num_states=params.states_per_l,
        )
        for n_index, (energy, orbital) in enumerate(zip(energies, orbitals), start=1):
            radial_states.append(
                RadialState(
                    n_index=n_index,
                    l=l,
                    energy=float(energy),
                    orbital=orbital,
                )
            )

    occupied = fill_occupations(radial_states, system.electrons)
    proposed_density = _density_from_states(occupied, r)
    proposed_density = np.maximum(proposed_density, 0.0)
    proposed_density = normalize_density_to_electron_count(proposed_density, r, system.electrons)

    # Energy expression uses the same potential terms as this fixed-potential solve.
    eigenvalue_sum = sum(state.occupancy * state.state.energy for state in occupied)
    hartree_energy = 0.5 * spherical_integral(input_density * v_h, r)
    xc_energy = spherical_integral(input_density * eps_xc, r)
    xc_potential_energy = spherical_integral(input_density * v_xc, r)
    total_energy = eigenvalue_sum - hartree_energy + xc_energy - xc_potential_energy

    return _SCFStep(
        effective_potential=effective_potential,
        proposed_density=proposed_density,
        occupied_states=occupied,
        eigenvalue_sum=float(eigenvalue_sum),
        hartree_energy=float(hartree_energy),
        xc_energy=float(xc_energy),
        xc_potential_energy=float(xc_potential_energy),
        total_energy=float(total_energy),
    )


def _density_from_states(occupied_states: list[OccupiedState], r: np.ndarray) -> np.ndarray:
    """Build n(r) from occupied radial states."""

    density = np.zeros_like(r)
    factor = 1.0 / (4.0 * np.pi * r * r)

    for occupied in occupied_states:
        density += occupied.occupancy * occupied.state.orbital * occupied.state.orbital * factor

    return density


def _initial_density_guess(system: AtomicSystem, r: np.ndarray) -> np.ndarray:
    """Hydrogenic starting guess with simple screening."""

    effective_z = max(0.5, float(system.atomic_number) - 0.35 * max(system.electrons - 1, 0))
    guess = (effective_z**3 / np.pi) * np.exp(-2.0 * effective_z * r)
    guess = guess * max(system.electrons, 1)
    guess = np.maximum(guess, 1.0e-12)

    return normalize_density_to_electron_count(guess, r, system.electrons)


def _build_notes(system: AtomicSystem, params: SCFParameters) -> list[str]:
    """Short notes to clarify simplifying assumptions."""

    notes = [
        "Educational finite-difference radial implementation.",
        "Spin-unpolarized LDA (Dirac exchange + Perdew-Zunger correlation).",
        "Accuracy depends on radial grid resolution and SCF mixing settings.",
    ]

    if system.electrons > 10:
        notes.append(
            "Warning: high electron counts may need larger l_max/states_per_l for stable occupation filling."
        )

    if not params.use_hartree:
        notes.append("Hartree term disabled (single-particle benchmark mode).")
    if not params.use_exchange and not params.use_correlation:
        notes.append("Exchange-correlation disabled.")

    return notes
